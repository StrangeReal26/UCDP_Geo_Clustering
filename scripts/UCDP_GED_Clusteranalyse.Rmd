---
title: "UCDP GED Clusteranalyse"
author: "Teichgräber"
date: "2026-02-16"
output:
  distill::distill_article:
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=FALSE}
library(lubridate)
library(dplyr)
library(ggplot2)
library(distill)
library(sf)
library(dbscan)
library(tidyr)
library(rnaturalearth)
library(rnaturalearthdata)
```

# Aufbau und Beschreibung der Datenanalyse

Text


```{r}
GED = read.csv("data/GEDEvent_v25_1_small.csv", sep = ";")
```

```{r}
View(GED)
```

```{r}
glimpse(GED)
```

```{r}
str(GED)
```

```{r}

# Prüfung fehlender Werte bei den geographischen Daten

sum(is.na(GED$latitude)); sum(is.na(GED$longitude))

```

```{r}

# Aufbereitung der Daten bzw. Variablen

GED <- GED |>
  mutate(
    
    # 1) Aktives Jahr: Der Wert der Variablen "true"/"false" wird von character nun als TRUE/FALSE (BOOLEAN) definiert
    
    active_year = tolower(active_year) == "true",

    # 2) Koordinaten: Das Dezimalzeichen wird von Komma zu Punkt geändert und als numeric definiert
    
    latitude  = as.numeric(gsub(",", ".", latitude)),
    longitude = as.numeric(gsub(",", ".", longitude)),

    # 3) Datum: Die variablen date_start und date_end werden von character in ein Datumsformat gebracht
    
    date_start = dmy(date_start),
    date_end = dmy(date_end),
    
  ) |>
  
  # 5) Zeilen mit fehlenden geographsichen Daten werden entfernt (sonst scheitert die spätere Datenanalyse)
  
  drop_na(latitude, longitude)

```

```{r}

# Die Länder der Region der späteren Clusteranalyse werden festgehalten (dfür wird ein Vektor genutzt)

sahel_countries <- c("Senegal",
                     "Mauritania",
                     "Mali",
                     "Burkina Faso",
                     "Niger",
                     "Chad",
                     "Sudan")

# Hier wird ein neuer Datensatz auf Grundlage der benötigten Filter definiert und geladen

GED_sahel <- GED |>
  filter(country %in% sahel_countries) |>
  filter(year >= 2000) |>
  filter(where_prec %in% c(1, 2)) |>
  filter(event_clarity == 1)

```

```{r}

# Überprüfung, ob die Filter korrekt sind und wie viele Beobachtungen übrig bleiben

unique(GED_sahel$country)

glimpse(GED_sahel)

```

```{r}

# Neuer Datensatz wird erstellt mit allen vorherigen Variablen und mit einer neuen Spalte geometry (geometrischer Punkt)

GED_sahel_sf <- GED_sahel |>
  st_as_sf(
    coords = c("longitude", "latitude"),  # x = longitude, y = latitude
    crs = 4326,                           # WGS84 / EPSG:4326 (Grad)
    remove = FALSE                        # Datensatz behält latitude/longitude als Spalten
  )

# Überprüfung: Welche Projektion/CRS hat das sf-Objekt?

st_crs(GED_sahel_sf)

# Überprüfung: Erste Geometrien anschauen

head(st_geometry(GED_sahel_sf))

```

```{r}

# Neuer Datensatz wird erstellt

# Es werden die Vorherig erstellten Koordinaten in Meter-Koordinaten auf Grundlage des LAEA erzeugt

# 1) Projektion definieren (LAEA) –> Zentrum grob in der Sahelzone

crs_laea_sahel <- "+proj=laea +lat_0=15 +lon_0=10 +datum=WGS84 +units=m +no_defs"

# 2) Transformation der Daten von WGS84 (Grad) zu LAEA (Meter)

GED_sahel_laea <- GED_sahel_sf |>
  st_transform(crs = crs_laea_sahel)

# 3) x/y-Koordinaten (in Metern) aus der Geometrie extrahieren

coords_m <- st_coordinates(GED_sahel_laea)

# Zusatz: x/y als Spalten zum Datensatz hinzufügen (hilfreich für Debug/Plots)

GED_sahel_laea <- GED_sahel_laea |>
  mutate(
    x_m = coords_m[, 1],
    y_m = coords_m[, 2]
  )

# Kurze Überprüfung: CRS und Größenordnung der Koordinaten

st_crs(GED_sahel_laea)
summary(GED_sahel_laea$x_m)
summary(GED_sahel_laea$y_m)

```

```{r}

# Clusteranalyse mit HDBSCAN clustering (explorativ)

# 1) Parameter setzen: Mindestgröße/Robustheit eines Clusters

minPts_value <- 30

# 2) HDBSCAN ausführen
# coords_m ist eine Matrix: Spalte 1 = x (m), Spalte 2 = y (m)

hdb <- hdbscan(coords_m, minPts = minPts_value)

# 3) Ergebnisse an Datensatz anhängen
# cluster: 0 = noise (kein Cluster), 1..k = Cluster-IDs
# membership_prob: "Sicherheit" der Zuordnung (0..1)

GED_sahel_laea <- GED_sahel_laea |>
  mutate(
    cluster_id = hdb$cluster,
    cluster_prob = hdb$membership_prob
  )

# 4) Erste Überprüfungen: Wie viele Cluster? Wie viel Noise?

table(GED_sahel_laea$cluster_id)

n_clusters <- length(setdiff(unique(GED_sahel_laea$cluster_id), 0))
noise_share <- mean(GED_sahel_laea$cluster_id == 0)

n_clusters
noise_share
summary(GED_sahel_laea$cluster_prob)

```

```{r}

# Bild zur Darstellung der Cluster mit ggplot2

p_clusters <- ggplot(GED_sahel_laea,
                     aes(x = longitude,
                         y = latitude,
                         color = factor(cluster_id))) +
  geom_point(size = 0.6, alpha = 0.7) +
  coord_equal() +
  labs(color = "Cluster ID",
       title = paste0("HDBSCAN clusters (minPts = ", minPts_value, ")")) +
  theme_minimal()

p_clusters

ggsave(
  filename = paste0("plots/hdbscan_clusters_minPts_", minPts_value, ".png"),
  plot = p_clusters,
  width = 10,
  height = 6,
  dpi = 300
)

```

```{r}

# Zusätzliche Abbildung: Karte (Sahel) + HDBSCAN-Cluster in Longitude/Latitude

# 1) Weltkarte als sf-Objekt laden

world_sf <- rnaturalearth::ne_countries(
  scale = "medium",        # ausreichend detailliert
  returnclass = "sf"
)

# 2) Nur Sahel-Länder auswählen (gleiche Länder wie im Filter oben!)

sahel_map_sf <- world_sf |>
  filter(name %in% sahel_countries)

# Optional: Falls du etwas mehr Raum um die Länder möchtest,
# könntest du stattdessen mit st_crop() arbeiten.


# 3) Plot erstellen

p_clusters_map <- ggplot() +
  
  # Hintergrund: Ländergrenzen
  geom_sf(
    data = sahel_map_sf,
    fill = "grey90",        # dezente Hintergrundfarbe
    color = "grey40",       # Ländergrenzen sichtbar
    linewidth = 0.3
  ) +
  
  # Clusterpunkte darüber
  geom_point(
    data = GED_sahel_laea,  # hier nutzen wir weiterhin longitude/latitude
    aes(
      x = longitude,
      y = latitude,
      color = factor(cluster_id)
    ),
    size = 0.6,
    alpha = 0.7
  ) +
  
  # Koordinatensystem
  coord_sf(
    xlim = range(GED_sahel_laea$longitude),
    ylim = range(GED_sahel_laea$latitude),
    expand = FALSE
  ) +
  
  labs(
    color = "Cluster ID",
    title = paste0("HDBSCAN clusters in the Sahel region (minPts = ", minPts_value, ")")
  ) +
  
  theme_minimal()

# Plot anzeigen

p_clusters_map


# 4) Speichern wie bisher

ggsave(
  filename = paste0("plots/hdbscan_clusters_map_africa.png"),
  plot = p_clusters_map,
  width = 10,
  height = 6,
  dpi = 300
)

```

```{r}

# Komplette Abbildung: Cluster + vollständige Afrika-Karte + Ländernamen

# 1) Alle afrikanischen Länder laden

africa_sf <- rnaturalearth::ne_countries(
  scale = "medium",
  continent = "Africa",
  returnclass = "sf"
)

# 2) Bounding Box auf Basis deiner tatsächlichen Daten erzeugen

bbox_sahel <- st_bbox(GED_sahel_sf)

# 3) Afrika-Karte auf genau diesen Bereich zuschneiden

africa_crop <- st_crop(africa_sf, bbox_sahel)

# 4) Plot erstellen

p_clusters_africa <- ggplot() +
  
  # Hintergrund: Länderflächen
  geom_sf(
    data = africa_crop,
    fill = "grey90",
    color = "grey40",
    linewidth = 0.3
  ) +
  
  # Ländernamen einfügen
  geom_sf_text(
    data = africa_crop,
    aes(label = name),
    size = 3,
    color = "black"
  ) +
  
  # Clusterpunkte
  geom_sf(
   data = GED_sahel_laea,
   aes(color = factor(cluster_id)),
   size = 0.6,
   alpha = 0.7
  ) +
  
  # Koordinatensystem
  coord_sf(
    xlim = c(bbox_sahel["xmin"], bbox_sahel["xmax"]),
    ylim = c(bbox_sahel["ymin"], bbox_sahel["ymax"]),
    expand = FALSE
  ) +
  
  labs(
    color = "Cluster ID",
    title = paste0("HDBSCAN clusters in geographic context (minPts = ", minPts_value, ")")
  ) +
  
  theme_minimal()

# Plot anzeigen

p_clusters_africa

# Speichern

ggsave(
  filename = paste0("plots/hdbscan_clusters_map_africa_complete.png"),
  plot = p_clusters_africa,
  width = 10,
  height = 6,
  dpi = 300
)

```

```{r}

# Kreuztabelle: cluster_id vs conflict_new_id

# Optional: Noise (cluster_id == 0) ausschließen, damit die Tabelle übersichtlicher wird

GED_sahel_clustered <- GED_sahel_laea |>
  filter(cluster_id != 0)

# Kreuztabelle (Counts)

tab_cluster_conflict <- table(
  GED_sahel_clustered$cluster_id,
  GED_sahel_clustered$conflict_new_id
)

# Ausgabe (kann sehr groß sein)
tab_cluster_conflict

```

```{r}

# Nennung aller Konflikte pro Cluster 

GED_sahel_laea |>
  filter(cluster_id != 0) |>
  count(cluster_id, conflict_new_id, name = "n") |>
  arrange(cluster_id, desc(n)) |>
  View()

```

```{r}

# Anzahl Konflikte pro Cluster mit Anzahl an Events (cluster_size)

GED_sahel_laea |>
  filter(cluster_id != 0) |>
  group_by(cluster_id) |>
  summarise(
    n_conflicts = n_distinct(conflict_new_id),
    cluster_size = n()
  ) |>
  arrange(desc(n_conflicts))

```

```{r}

# Dominanter Konflikt pro Cluster (share/purity-like measure)

dominance_by_cluster <- GED_sahel_clustered |>
  count(cluster_id, conflict_new_id, name = "n") |>
  group_by(cluster_id) |>
  mutate(
    cluster_size = sum(n),
    share = n / cluster_size
  ) |>
  arrange(cluster_id, desc(share)) |>
  slice(1) |>
  ungroup() |>
  select(cluster_id, conflict_new_id, cluster_size, n_dominant = n, dominant_share = share)

dominance_by_cluster

```

```{r}

# Top-Konflikt pro Cluster

top_conflicts_by_cluster <- GED_sahel_clustered |>
  count(cluster_id, conflict_new_id, name = "n") |>
  group_by(cluster_id) |>
  mutate(share = n / sum(n)) |>
  arrange(cluster_id, desc(share)) |>
  slice_head(n = 5) |>
  ungroup()

top_conflicts_by_cluster

```

```{r}

# Plot 1: Anzahl Konflikte pro Cluster (Balkendiagramm)

conflicts_per_cluster <- GED_sahel_laea |>
  filter(cluster_id != 0) |>
  group_by(cluster_id) |>
  summarise(
    n_conflicts = n_distinct(conflict_new_id),
    cluster_size = n(),
    .groups = "drop"
  ) |>
  arrange(cluster_id)

p_conflicts <- ggplot(conflicts_per_cluster,
                      aes(x = factor(cluster_id), y = n_conflicts)) +
  geom_col() +
  labs(
    title = "Number of distinct conflicts per HDBSCAN cluster",
    subtitle = paste0("minPts = ", minPts_value, " (Noise excluded)"),
    x = "Cluster ID",
    y = "Number of distinct conflicts"
  ) +
  theme_minimal()

p_conflicts

ggsave(
  filename = paste0("plots/bar_n_conflicts_per_cluster_minPts_", minPts_value, ".png"),
  plot = p_conflicts,
  width = 10,
  height = 6,
  dpi = 300
)

```

```{r}

# Plot 2: Dominant Share pro Cluster (Homogenität)

p_dominance <- ggplot(dominance_by_cluster,
                      aes(x = factor(cluster_id), y = dominant_share)) +
  geom_col() +
  labs(
    title = "Dominant conflict share per HDBSCAN cluster",
    subtitle = paste0("minPts = ", minPts_value, " (Noise excluded)"),
    x = "Cluster ID",
    y = "Dominant share within cluster"
  ) +
  theme_minimal()

p_dominance

ggsave(
  filename = paste0("plots/bar_dominant_share_per_cluster_minPts_", minPts_value, ".png"),
  plot = p_dominance,
  width = 10,
  height = 6,
  dpi = 300
)

```
